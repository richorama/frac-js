<!DOCTYPE html>
<html lang="en" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frac-js</title>

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
        crossorigin=""/>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
        crossorigin=""></script>
    <style>
        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
        }
    </style>

</head>

<body onload="go()">
    <div id="map"></div>

    <script>

const WorkDistribution = function(options) {
  let queue = []
  const pool = []

  // set up workers
  for (let i = 0; i < (options.concurrency || 4); i++) {
    const worker = new Worker(options.src)
    worker.onerror = (e) => console.error('Worker error:', e)
    worker.working = false
    pool.push(worker)
  }

  // execute the next item of work
  const processQueue = function() {
    // remove cancelled work items
    queue = queue.filter(work => !work.cancel)
    if (!queue.length) return
    const nextWorker = pool.filter(x => !x.working)[0]
    if (!nextWorker) return

    const work = queue.pop()

    nextWorker.working = true
    nextWorker.onmessage = function(e) {
      nextWorker.working = false
      if (work.cancel) return // don't bother to notify if cancelled
      work.cb(e)
      processQueue()
    }
    nextWorker.postMessage(work.item)
  }

  return {
    push: function(item, cb) {
      const work = { item: item, cb: cb, cancel: false }
      queue.push(work)
      processQueue()
      return () => (work.cancel = true)
    }
  }
}

const options = {
  centre: [-128, 128],
  tileSize: 256,
  depth: 48 // precision is lost at any greater level
}

function go() {
  const workPool = WorkDistribution({
    concurrency: navigator.hardwareConcurrency,
    src: 'worker.js'
  })

  const map = L.map('map', {
    crs: L.CRS.Simple,
    maxZoom: options.depth
  }).setView(options.centre, 2)

  L.GridLayer.Fractal = L.GridLayer.extend({
    initialize: function(opts) {
      L.GridLayer.prototype.initialize.call(this, L.Util.extend({
        tileSize: options.tileSize,
        attribution: "<a href='https://github.com/richorama/frac-js'>frac-js</a>",
        keepBuffer: 4
      }, opts))
      this.on('tileunload', e => {
        if (e.tile.cancel) e.tile.cancel()
      })
    },
    setType: function(value) {
      this._type = value
    },
    createTile: function(coords, done) {
      const tile = document.createElement('canvas')
      tile.width = tile.height = options.tileSize
      tile.cancel = workPool.push(
        { coords: coords, type: this._type || 'mandelbrot' },
        e => {
          const ctx = tile.getContext('2d')
          ctx.putImageData(e.data.imageData, 0, 0)
          done(null, tile)
        }
      )
      return tile
    }
  })

  L.gridLayer.mandelbrot = () => {
    const layer = new L.GridLayer.Fractal()
    layer.setType('mandelbrot')
    return layer
  }

  const mandelbrot = L.gridLayer.mandelbrot().addTo(map)

  L.gridLayer.julia = () => {
    const layer = new L.GridLayer.Fractal()
    layer.setType('julia')
    return layer
  }

  const julia = L.tileLayer.julia()

  L.control.layers({ mandelbrot, julia }).addTo(map)
}


    </script>

</body>

</html>